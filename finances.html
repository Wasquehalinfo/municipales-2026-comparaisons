<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Courbe de la dette + debug CSV</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
    .wrap { max-width: 1100px; margin: 0 auto; }
    h1 { margin: 0 0 10px; font-size: 20px; }
    #status { margin: 8px 0 18px; color: #444; }
    .card { border: 1px solid #e5e5e5; border-radius: 12px; padding: 16px; margin-bottom: 16px; }
    canvas { width: 100%; height: 420px; }

    details { margin-top: 10px; }
    summary { cursor: pointer; font-weight: 600; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 14px; }
    th, td { border: 1px solid #eaeaea; padding: 8px; text-align: left; }
    th { background: #f7f7f7; }
    .muted { color: #666; font-size: 13px; }
    code { background: #f6f6f6; padding: 2px 6px; border-radius: 6px; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Courbe de la dette (CSV Google Sheets) + affichage des points</h1>
  <div id="status">Chargement…</div>

  <div class="card">
    <canvas id="chart"></canvas>
    <div class="muted" style="margin-top:10px">
      Source : <code id="src"></code>
    </div>
  </div>

  <div class="card">
    <details open>
      <summary>Points extraits (debug)</summary>
      <div class="muted">
        On affiche ce qui est lu sur la ligne des années (ligne 1, E→U) et la ligne de dette (ligne 20, E→U),
        puis on inverse l’ordre pour afficher la chronologie (2008 → 2024).
      </div>
      <div id="debug"></div>
    </details>
  </div>
</div>

<!-- CSV parser -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<script>
  // === CONFIG ===
  const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vT1OlpocgYWZCF_AB7jE8a3885mIFLfysIonoRyTgQAfxdTbF7JFwz3HbetjrYAQN4LBZDe-DWvSd7F/pub?gid=0&single=true&output=csv";

  const YEAR_ROW_1_BASED = 1;     // ligne 1
  const DEBT_ROW_1_BASED = 20;    // ligne 20

  const COL_START = "E";          // de E
  const COL_END   = "U";          // à U

  // Unité affichée
  const CURRENCY_SYMBOL = "€";
  const SERIES_LABEL = `Dette (en euros)`;
  const Y_AXIS_TITLE = `Dette (en euros)`;
  // =============

  document.getElementById("src").textContent = CSV_URL;

  // Convertit une lettre de colonne Excel (A, B, ..., Z, AA...) en index 0-based
  function excelColToIndex(colLetters) {
    let n = 0;
    const s = colLetters.trim().toUpperCase();
    for (let i = 0; i < s.length; i++) n = n * 26 + (s.charCodeAt(i) - 64);
    return n - 1;
  }

  function toNumber(v) {
    if (v === null || v === undefined) return null;
    const s = String(v).trim();
    if (!s) return null;

    // Normalise espaces et insécables
    let t = s.replace(/\u00A0/g, " ").replace(/\s+/g, "");

    // Heuristique FR : si virgule, on considère la virgule décimale
    if (t.includes(",")) {
      t = t.replace(/\./g, "").replace(/,/g, ".");
    }

    // Retire tout sauf chiffres, signe, point, exponentiel
    t = t.replace(/[^0-9eE.+-]/g, "");

    const num = Number(t);
    return Number.isFinite(num) ? num : null;
  }

  function cleanYearLabel(v) {
    const s = String(v ?? "").trim();
    if (!s) return "";
    // Convertit "2010.0" -> "2010" si possible
    const n = Number(s.replace(",", "."));
    if (Number.isFinite(n)) return String(Math.trunc(n));
    return s;
  }

  async function loadCsv(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const text = await res.text();
    return new Promise((resolve, reject) => {
      Papa.parse(text, {
        skipEmptyLines: true,
        complete: (results) => resolve(results.data),
        error: (err) => reject(err)
      });
    });
  }

  function pickRange(row, startIdx, endIdx) {
    const out = [];
    for (let i = startIdx; i <= endIdx; i++) out.push(row?.[i] ?? "");
    return out;
  }

  function escapeHtml(s) {
    return String(s ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function indexToExcelCol(idx0) {
    // 0->A
    let n = idx0 + 1;
    let s = "";
    while (n > 0) {
      const r = (n - 1) % 26;
      s = String.fromCharCode(65 + r) + s;
      n = Math.floor((n - 1) / 26);
    }
    return s;
  }

  function renderDebugTable(container, rows) {
    const html = `
      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Col.</th>
            <th>Année (raw)</th>
            <th>Année (clean)</th>
            <th>Dette (raw)</th>
            <th>Dette (num)</th>
            <th>Utilisé ?</th>
          </tr>
        </thead>
        <tbody>
          ${rows.map(r => `
            <tr>
              <td>${r.idx}</td>
              <td>${r.col}</td>
              <td>${escapeHtml(r.yearRaw)}</td>
              <td>${escapeHtml(r.yearClean)}</td>
              <td>${escapeHtml(r.debtRaw)}</td>
              <td>${r.debtNum === null ? "" : r.debtNum.toLocaleString("fr-FR")}</td>
              <td>${r.used ? "✅" : "—"}</td>
            </tr>
          `).join("")}
        </tbody>
      </table>
    `;
    container.innerHTML = html;
  }

  (async () => {
    const status = document.getElementById("status");
    const debugEl = document.getElementById("debug");

    try {
      const data = await loadCsv(CSV_URL);

      const yearRowIdx = YEAR_ROW_1_BASED - 1;
      const debtRowIdx = DEBT_ROW_1_BASED - 1;

      const startIdx = excelColToIndex(COL_START);
      const endIdx   = excelColToIndex(COL_END);

      if (!data[yearRowIdx]) throw new Error(`Ligne ${YEAR_ROW_1_BASED} introuvable dans le CSV.`);
      if (!data[debtRowIdx]) throw new Error(`Ligne ${DEBT_ROW_1_BASED} introuvable dans le CSV.`);

      const yearsRaw = pickRange(data[yearRowIdx], startIdx, endIdx);
      const debtRaw  = pickRange(data[debtRowIdx], startIdx, endIdx);

      // Labels et valeurs alignés (même longueur)
      let labels = yearsRaw.map(cleanYearLabel);
      let values = debtRaw.map(toNumber).map(v => (v === null ? null : v));

      // Inversion chronologique (2008 → 2024)
      labels = labels.reverse();
      values = values.reverse();

      // Debug rows (E..U) — on montre l’ordre final (après inversion)
      const debugRows = [];
      for (let i = 0; i < labels.length; i++) {
        // Après inversion, la correspondance colonne Excel n'est plus directe,
        // donc on garde la colonne source "originale" calculée à l’envers.
        const originalColIdx0 = endIdx - i;
        const used = Boolean(labels[i]) && (values[i] !== null);
        debugRows.push({
          idx: i + 1,
          col: indexToExcelCol(originalColIdx0),
          yearRaw: yearsRaw[yearsRaw.length - 1 - i],
          yearClean: labels[i],
          debtRaw: debtRaw[debtRaw.length - 1 - i],
          debtNum: values[i],
          used
        });
      }
      renderDebugTable(debugEl, debugRows);

      const usedCount = debugRows.filter(r => r.used).length;
      status.textContent = `OK — ${labels.length} années lues (E→U), ${usedCount} points exploitables. Affichage chronologique (2008 → 2024).`;

      // Courbe
      const ctx = document.getElementById("chart");
      new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets: [{
            label: SERIES_LABEL,
            data: values,
            spanGaps: true,
            tension: 0.25,
            pointRadius: 3
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: true },
            tooltip: {
              callbacks: {
                label: (ctx) => {
                  const v = ctx.parsed.y;
                  if (v === null || v === undefined) return `${SERIES_LABEL}: —`;
                  return `${SERIES_LABEL} : ${Number(v).toLocaleString("fr-FR")} ${CURRENCY_SYMBOL}`;
                }
              }
            }
          },
          scales: {
            x: {
              type: "category",
              title: { display: true, text: "Année" },
              ticks: { autoSkip: true, maxRotation: 0 }
            },
            y: {
              title: { display: true, text: Y_AXIS_TITLE },
              ticks: {
                callback: (v) => Number(v).toLocaleString("fr-FR") + " " + CURRENCY_SYMBOL
              }
            }
          }
        }
      });

    } catch (e) {
      status.textContent = "Erreur : " + (e?.message ?? e);
      console.error(e);
      debugEl.innerHTML = `<div class="muted">Impossible d'afficher le debug.</div>`;
    }
  })();
</script>
</body>
</html>
