<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Courbe de la dette</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
    .wrap { max-width: 980px; margin: 0 auto; }
    h1 { margin: 0 0 12px; font-size: 20px; }
    #status { margin: 8px 0 18px; color: #444; }
    .card { border: 1px solid #e5e5e5; border-radius: 12px; padding: 16px; }
    canvas { width: 100%; height: 440px; }
    code { background: #f6f6f6; padding: 2px 6px; border-radius: 6px; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Courbe de la dette (CSV Google Sheets)</h1>
  <div id="status">Chargement…</div>

  <div class="card">
    <canvas id="chart"></canvas>
  </div>

  <p style="margin-top:14px;color:#555">
    Source : <code id="src"></code>
  </p>
</div>

<!-- CSV parser -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<script>
  // === CONFIG À ADAPTER SI BESOIN ===
  const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vT1OlpocgYWZCF_AB7jE8a3885mIFLfysIonoRyTgQAfxdTbF7JFwz3HbetjrYAQN4LBZDe-DWvSd7F/pub?gid=0&single=true&output=csv";

  const YEAR_ROW_1_BASED = 1;     // ligne 1
  const DEBT_ROW_1_BASED = 20;    // ligne 20

  const COL_START = "E";          // de E
  const COL_END   = "U";          // à U
  // ================================

  document.getElementById("src").textContent = CSV_URL;

  // Convertit une lettre de colonne Excel (A, B, ..., Z, AA...) en index 0-based
  function excelColToIndex(colLetters) {
    let n = 0;
    const s = colLetters.trim().toUpperCase();
    for (let i = 0; i < s.length; i++) {
      n = n * 26 + (s.charCodeAt(i) - 64);
    }
    return n - 1;
  }

  function toNumber(v) {
    // Nettoyage robuste : espaces, séparateurs milliers, virgules décimales, etc.
    if (v === null || v === undefined) return null;
    const s = String(v).trim();
    if (!s) return null;

    // Enlève espaces insécables & espaces
    let t = s.replace(/\u00A0/g, " ").replace(/\s+/g, "");

    // Si format FR "1.234,56" ou "1234,56" → passe la virgule en point
    // et enlève les séparateurs milliers éventuels.
    // Heuristique simple :
    // - si contient "," : on considère "," comme décimale
    // - on enlève les "." (milliers) puis on remplace "," par "."
    if (t.includes(",")) {
      t = t.replace(/\./g, "").replace(/,/g, ".");
    }

    // Enlève tout sauf chiffres, signe, point, exponentiel
    t = t.replace(/[^0-9eE.+-]/g, "");

    const num = Number(t);
    return Number.isFinite(num) ? num : null;
  }

  async function loadCsv(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const text = await res.text();
    return new Promise((resolve, reject) => {
      Papa.parse(text, {
        skipEmptyLines: true,
        complete: (results) => resolve(results.data),
        error: (err) => reject(err)
      });
    });
  }

  function pickRange(row, startIdx, endIdx) {
    // endIdx inclus
    const out = [];
    for (let i = startIdx; i <= endIdx; i++) out.push(row?.[i] ?? "");
    return out;
  }

  (async () => {
    const status = document.getElementById("status");
    try {
      const data = await loadCsv(CSV_URL);

      const yearRowIdx = YEAR_ROW_1_BASED - 1;
      const debtRowIdx = DEBT_ROW_1_BASED - 1;

      const startIdx = excelColToIndex(COL_START);
      const endIdx   = excelColToIndex(COL_END);

      if (!data[yearRowIdx]) throw new Error(`Ligne ${YEAR_ROW_1_BASED} introuvable dans le CSV.`);
      if (!data[debtRowIdx]) throw new Error(`Ligne ${DEBT_ROW_1_BASED} introuvable dans le CSV.`);

      const yearsRaw = pickRange(data[yearRowIdx], startIdx, endIdx);
      const debtRaw  = pickRange(data[debtRowIdx], startIdx, endIdx);

      const labels = yearsRaw.map(v => String(v).trim());
      const values = debtRaw.map(toNumber);

      // Filtre des points invalides (au cas où certaines cellules sont vides)
      const points = [];
      for (let i = 0; i < labels.length; i++) {
        if (labels[i] && values[i] !== null) points.push({ x: labels[i], y: values[i] });
      }

      if (points.length === 0) {
        throw new Error("Aucune donnée numérique trouvée sur la ligne de dette (dans la plage E→U).");
      }

      status.textContent = `OK — ${points.length} points chargés.`;

      const ctx = document.getElementById("chart");

      new Chart(ctx, {
        type: "line",
        data: {
          datasets: [{
            label: "Dette",
            data: points,
            tension: 0.25,
            pointRadius: 3
          }]
        },
        options: {
          responsive: true,
          parsing: false, // on fournit déjà {x,y}
          plugins: {
            legend: { display: true },
            tooltip: {
              callbacks: {
                label: (c) => `${c.dataset.label}: ${c.parsed.y}`
              }
            }
          },
          scales: {
            x: {
              title: { display: true, text: "Année" }
            },
            y: {
              title: { display: true, text: "Dette" },
              ticks: {
                callback: (v) => v
              }
            }
          }
        }
      });

    } catch (e) {
      status.textContent = "Erreur : " + (e?.message ?? e);
      console.error(e);
    }
  })();
</script>
</body>
</html>
